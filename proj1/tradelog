#!/bin/bash

export POSIXLY_CORRECT=yes
export LC_ALL=C

#Vypsání chyby a ukončení skriptu
trap 'catch $? $LINENO' ERR
catch() {
  echo "ERROR: code $1 on line $2" 1>&2
  exit $1
}

#Vypíše zprávné použití, ukončí skript
help_msg () {
    echo "Usage: tradelog [-h|--help] [FILTERS] [COMMAND] [LOG [LOG2 [...]]"
    echo
    echo "COMMAND can be one of:"
    echo "list-tick – list of all tickers"
    echo "profit – profit from all closed positions"
    echo "pos – list of values of all currently held positions sorted descending by value"
    echo "last-price – list of last currently known prices for tickers"
    echo "hist-ord – histograms of number of transactions by tickers"
    echo "graph-pos – graph of values of currently held positions by tickers"
    echo
    echo "FILTER can be one of:"
    echo "-a DATETIME – after: only records AFTER the date are considered (excluding the date). The format of DATETIME is YYYY-MM-DD HH:MM:SS."
    echo "-b DATETIME – before: only records BEFORE the date are considered (excluding the date)"
    echo "-t TICKER – only records with the given ticker are considered, multiple tickers (each with -t) can be given"
    echo "-w WIDTH – sets the width of the longest line of graph listings (this filter can only be set once per execution)"
    echo "-h a --help - prints this message"
    exit 0
}

#kontrola dvojitého zadání parametru
parseFlag () {
    if [ -n "$(eval echo "\$$1")" ]; then
        echo "ERROR: Filter $1 can only be given once!" 1>&2
        echo "Usage: tradelog [-h|--help] [FILTERS] [COMMAND] [LOG [LOG2 [...]]" 1>&2
        exit 1
    fi
}

parseCmd () {
    if [ -n "$cmd" ]; then
        echo "ERROR: Only one command is supported!" 1>&2
        echo "Usage: tradelog [-h|--help] [FILTERS] [COMMAND] [LOG [LOG2 [...]]" 1>&2
        exit 1
    fi

    cmd="$1"
}

#parsování argumentů
i=1
while [ $i -le $# ]; do
    case $(eval echo "\$$i") in
        -a)  i=$((i+1)); parseFlag after_date; after_date=$(eval echo "\$$i");;
        -b)  i=$((i+1)); parseFlag before_date; before_date=$(eval echo "\$$i");;
        -t)  i=$((i+1)); tickers=$tickers $(eval echo "\$$i");;
        -w)  i=$((i+1)); parseFlag width; width=$(eval echo "\$$i");;
        -h | --help) help_msg;;
        list-tick) parseCmd "list-tick";;
        profit) parseCmd "profit";;
        pos) parseCmd "pos";;
        last-price) parseCmd "last-price";;
        hist-ord) parseCmd "hist-ord";;
        graph-pos) parseCmd "graph-pos";;
        *)  files=$files $(eval echo "\$$i");;
    esac
    i=$((i+1))
done

files=$(echo "$files" | xargs) #ořezání mezery na konci $files

#když jsou zadány vstupní soubory, uložíme jejich obsah do $out, jinak uložíme stdin
if [ -n "$files" ]; then
    for i in $files; do
        if [ -f "$i" ]; then
            if [ "$(printf $i | tail -c 3)" = ".gz" ]; then
                out=$(zcat "$i")
            else
                out+=$(cat "$i")
            fi
        else
            echo "ERROR: File $i not found!" 1>&2
            exit 1
        fi
    done
else
    out=$(cat)
fi

#provede filtrování
if [ -n "$after_date" ]; then
    out=$(echo "$out" | awk -F ';' -v date="$after_date" '{if ($1 > date) print}') 
fi
if [ -n "$before_date" ]; then
    out=$(echo "$out" | awk -F ';' -v date="$before_date" '{if ($1 < date) print}') 
fi
if [ -n "$tickers" ]; then
    out=$(echo "$out" | awk -F ';' -v TICKERS="$tickers" 'BEGIN{n = split(TICKERS, tickers, " ")} 
                                                          {for(i = 1; i <= n; i++) if($2 == tickers[i]) print}')
fi

#provede příkaz
case "$cmd" in
    list-tick) echo "$out" | awk -F ';' '
        {
            if(ticker[$2]++ == 0) print($2);
        }' | sort;;
    profit) echo "$out" | awk -F ';' '
        {
            out += ($3 == "sell") ? $4 * $6 : -$4 * $6;
        } 
        END{
            printf("%.2f\n", out);
        }';;
    pos) echo "$out" | awk -F ';'  '
        {
            count[$2] += ($3 == "sell") ? -$6 : $6; 
            price[$2] = $4;
        } 
        END{
            for(var in count){
                len = length(sprintf("%.2f", count[var] * price[var])); 
                if(len > max) max = len;
            }
            for(var in count){
                printf("%-10s:%*.2f\n", var, max + 1, count[var] * price[var]);
            }
        }' | sort -r -n -t ':' -k 2;;
    last-price) echo "$out" | awk -F ';' '
        {
            price[$2] = $4;
            len = length(sprintf("%.2f", price[$2]));
            if(len > max) max = len;
        } 
        END{
            for(var in price){
                printf("%-10s:%*.2f\n", var, max + 1, price[var]);
            }
        }' | sort;;
    hist-ord) echo "$out" | awk -F ';' -v width="$width" '
        {
            count[$2]++;
            if(count[$2] > maxCount) maxCount = count[$2];
        } 
        END{
            for(var in count){
                printf("%-10s: ", var); 
                max = (width == "") ? count[var] : int(width / maxCount * count[var]); 
                for(i = 0; i < max; i++){
                    printf("#");
                } 
                printf("\n");
            }
        }' | sort;;
    graph-pos) echo "$out" | awk -F ';' -v width="$width" '
        {
            count[$2] += ($3 == "sell") ? -$6 : $6; 
            price[$2] = $4;
        } 
        END{
            for(var in count){
                absCount = (count[var] < 0) ? -count[var] : count[var];
                if(absCount * price[var] > maxCount) 
                    maxCount = absCount * price[var];
            }
            for(var in count){
                printf("%-10s: ", var); 
                currPos = count[var] * price[var];
                if(currPos > 0) out = "#";
                else{
                    currPos = -currPos;
                    out = "!";
                }
                if(width == "") 
                    max = int(currPos / 1000);
                else 
                    max = int(width / maxCount * currPos); 
                for(i = 0; i < max; i++){
                    printf("%s", out);
                } 
                printf("\n");
            }
        }' | sort;;
    *) echo "$out"
esac
